{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python tips and tools","text":"<p>Howdy! I present you some notes meant as a companion to the Python tips and tools talk for the Superconducting Qubit Technology school at Benasque 2023.</p> <p>Since there are abundant online resources to learn Python, this document is quite succint and schematic. I tried to keep the files simple enough so that the essence of a Python project can be understood, but rich enough so that you, hopefully, learn new things! (No, we are not going to print \"hello world\" or explain <code>for</code> loops).</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Getting started<ul> <li>Conda</li> <li>Create a project and initialize git</li> <li>Pip and PyPI</li> <li>Jupyter notebooks</li> <li>Text editor or IDE</li> </ul> </li> <li>Python basics<ul> <li>Project structure</li> <li>Packages or libraries</li> <li>Modules</li> <li>Objects and classes</li> <li>Variables</li> <li>Type hints</li> <li>Docstrings</li> </ul> </li> <li>Tools<ul> <li>Testing</li> <li>Debugging</li> <li>Timing</li> <li>Profiling</li> <li>Linting</li> <li>Formatting</li> <li>Type checker</li> </ul> </li> <li>Bit more advanced stuff<ul> <li>Code acceleration</li> <li>Installing the library</li> <li>Creating documentation</li> <li>Building and uploading to PyPI</li> <li>Automating boring tasks with Github workflows</li> <li>Command line interface</li> </ul> </li> <li>Other things to look into</li> <li>Online resources</li> </ol>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#conda","title":"Conda","text":"<p>The first thing we should do when working on a new project is to create a virtual environment that suits our third-party library needs (with their corresponding versions), unless we already have one. I personally use the light version of conda, <code>miniconda</code>, which only installs the standard Python libraries. Then you can always install whatever you need in a new environment to keep it all clean and tidy. Other alternatives to <code>conda</code> exist, like venv (part of the standard library), <code>Poetry</code> and <code>Pipenv</code>.</p> <p>So, we start by creating and activating a new environment</p> <p><pre><code>$ conda create -n env_name python==3.10\n$ conda activate env_name\n</code></pre> Note: always remember to activate your environment before using Python or installing new libraries. Do not install third party libraries in the base environment!</p>"},{"location":"#create-a-project-and-initialize-git","title":"Create a project and initialize git","text":"<p>Next, we create our project folder and initialize git inside it, so we can use version control. <pre><code>$ mkdir my_project\n$ cd my_project\n$ git init\n</code></pre></p> <p>or, instead, we can clone this repository <pre><code>$ git clone https://github.com/pablovegan/Python-tips-tools.git\n</code></pre></p> <p>Note: be sure to push and pull your changes to and from the cloud (e.g. Github or Gitlab) when switching between different devices (for example, your desktop computer and your laptop). Otherwise, you can have merge conflicts and, trust me, you don't want that...</p>"},{"location":"#pip-and-pypi","title":"Pip and PyPI","text":"<p>Once Python is installed, we can use either <code>pip</code> or <code>conda</code> to install new libraries in our environment. <code>pip</code> downloads packages from the PyPI repository (Python Package Index), which usually has more libraries than the Conda repository.</p> <p>To simplify our life, we will install the third-party libraries we need from a .txt file named <code>requirements-dev.txt</code>, which also installs the dependencies in the <code>requirements.txt</code> file (intended just for users of the library, not developers). <pre><code>$ pip install -r requirements-dev.txt\n</code></pre></p>"},{"location":"#jupyter-notebooks","title":"Jupyter notebooks","text":"<p>If we also want to run jupyter notebooks, we must install the package <code>ipykernel</code>:  <pre><code>$ pip install ipykernel\n</code></pre></p>"},{"location":"#text-editor-or-ide","title":"Text editor or IDE","text":"<p>I'm a Visual Studio Code (VSCode) enjoyer because it is free, lightweight and has lots of useful extensions, but you may also try other IDEs and editors like PyCharm, Sublime or Vim (for the nostalgic).</p> <p>Here are some of the extensions I use in VSCode:</p> <ul> <li>Python</li> <li>IntelliCode</li> <li>Jupyter</li> <li>Ruff</li> <li>GitHub Pull requests and issues</li> <li>Gitlens</li> <li>autoDocstring</li> </ul> <p>One tip for VSCode: you can hide cache folders from the file explorer in <code>Settings -&gt; Files: Exclude</code>.</p>"},{"location":"#python-basics","title":"Python basics","text":""},{"location":"#project-structure","title":"Project structure","text":"<p>Once we have a folder for our project, we equip it with the following structure:</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 ... other files ...\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 mypackage\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 vector\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 vector.py\n\u2502   \u2514\u2500\u2500 linearmap\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 linear_map.py\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_linear_map.py\n\u2502   \u2514\u2500\u2500 test_vector.py\n\u2514\u2500\u2500 examples\n    \u2514\u2500\u2500 example.ipynb\n</code></pre> <p>First, we find the README, which contains whatever useful information the author of the repository wants to transmit us. Usually it begins with a short description of the package, and follows with sections on how to install it, a quick usage guide, references, how to contribute and the license (see <code>README_template.md</code> for an example).</p> <p>Next we find <code>pyproject.toml</code>, a configuration file with metadata about our project and configuration options for the tools that we use during development (e.g. linters and formatters). Usually you can copy configuration files from other projects (like this one) and tweak them to fit your needs.</p> <p>Third party dependencies for our package are specified in the <code>requirements.txt</code> file, ideally with the version of each library to avoid conflicts with updates or older versions. The resting developer tools that we'd like to use are added in the <code>requirements-dev.txt</code> file. Tip: you can specify the dependencies inside the <code>pyproject.toml</code> file to avoid having extra files.</p> <p>After a bunch of other files, we find our main package, with all our Python code organized in folders. Sometimes the package can be found inside a source folder, <code>src</code>, in a similar way to other programming languajes (like Java), but in Python is not really necessary so we can skip it.</p> <p>In the <code>tests</code> folder we store the code needed to assert that our library is working as intented to. This shouldn't be mixed with the <code>examples</code> folder; sometimes we tend to test our code in jupyter notebooks, but it is better to define a set of tests that we expect our library to pass every single time, and then just use it for whatever examples we want.</p> <p>For the moment, we will not worry about the <code>docs</code> folder (files to create documentation) or the <code>.github</code> folder (contains workflows) found in this repository; we will get to it in the advanced stuff section.</p>"},{"location":"#packages-or-libraries","title":"Packages or libraries","text":"<p>A package or library is a collection of Python <code>.py</code> modules organized in directories. The main directory is the package and the subdirectories are its subpackages, with their names following the <code>lowercasenames</code> convention, without underscores.</p> <p>As you may have noticed in the project structure, every folder inside our package has a <code>__init__.py</code> file (read \"dunder init\"). The code inside it will be called whenever we import the library. Usually, it only contains imports of functions or classes from other <code>.py</code> files or directories at the same level, but it can include any piece of code.</p> <p>The <code>tests</code> folder can also contain a <code>__init__.py</code> file, but we can leave it empty since we are not going to import the tests package.</p>"},{"location":"#modules","title":"Modules","text":"<p>Simply, a module is a <code>.py</code> file consisting of Python code. A module can define functions, classes and variables...</p> <p>Python modules should more or less follow this structure:</p> <ol> <li>Module docstrings should appear at the very beginning, just before the imports. </li> <li>Imports should follow this order:</li> <li><code>__future__</code></li> <li><code>standard_libraries</code></li> <li><code>third_party</code></li> <li><code>first_party</code></li> <li> <p><code>local_folder</code></p> <p>with each group separated by one empty line. Also, one should not import from more than one library per line. </p> <p>Tip: You can use <code>isort</code> to sort automatically all your imports.</p> </li> <li> <p>Module constants, separated from the imports by two empty lines. Constants should follow the <code>UPPER_CASE_WITH_UNDERSCORES</code> naming convention.</p> </li> <li>Functions, separated again by two empty lines. Function names should follow the <code>lower_case_with_underscores</code> convention.</li> <li>Exception classes.</li> <li>Normal classes. Classes names should stick to the <code>CapitalizedWords</code> convention.</li> </ol> <p>There is no exact rule on how much code should be in each module, but, ideally, each module should have one purpose (as with functions). For example, the purpose of our modules <code>vector.py</code> and <code>linear_map.py</code> are defining the <code>Vector</code> class and creating some linear transforms for those vectors with the <code>LinearMap</code> class and its subclasses, respectively.</p>"},{"location":"#objects-and-classes","title":"Objects and classes","text":"<p>Python is an object oriented language; everything in Python is an object (even packages!), i.e. any data with a state (attributes) and defined behavior (methods). Attributes are values associated with an object; they are usually referenced by name using dotted expressions.</p> <p>A class is a template for creating user-defined objects and normally contains methods which operate on instances of the class. Methods are functions defined inside a class body. (For an in-depth introduction to classes in Python see).</p> <p>Every class in Python has, ultimately, <code>type</code> as a base class (more on subclasses and inheritance later on). When we instantiate a new object of a certain class (for example, <code>obj = myclass()</code>), the <code>__call__</code> method of <code>type</code> is invoked in the background, which in turn calls the <code>__new__</code> and <code>__init__</code> methods: the former creates a new empty object of the class, while the latter initializes the object.</p> <pre><code>class Friend:\n\"\"\"The class represents a friend with their main interests.\"\"\"\n\n    def __init__(fav_movie: str) -&gt; None:\n\"\"\"Method to initialize our friend with a 'fav_movie' attribute.\"\"\"\n        self.fav_movie = fav_movie\n\n\niris = Friend(fav_movie=\"Shrek\")\nprint(f\"{iris.fav_movie = }\")  # access the fav_movie attribute of iris\n</code></pre> <p>Tip: <code>__init__</code> should initialize all the attributes of the class, even if they are defined inside other methods, case in which you just initialize the attributes to <code>None</code>. This allows anyone to see at a glance all the attributes of your class without having to read through all the code.</p> <p>In Python, methods that start and end with the double underscores are called special methods (also called magic methods or dunder methods). Special methods are called internally by Python, so they are not meant to be invoked directly by you. For example, when you add two integers using the + operator, Python is implicitly calling the <code>__add__()</code> method inside the <code>int</code> class.</p> <p>Another common naming convention is related to the fact that Python doesn\u2019t distinguish between private, protected and public attributes like Java and other languages do. In Python, all attributes and methods are accessible, so to distinguish the ones for internal use only from the ones intended for users (public API), we begin this \"private\" attributes with an underscore. An example is the <code>_get_inverse()</code> function in our <code>linear_map.py</code> module. In the user interface (API), the inverse is accessed via a \"public\" attribute <code>inv_matrix</code> rather than the \"private\" method.</p> <p>Two important properties of python classes are inheritance and polymorphism. Inheritance allows us to create a subclass that can access the methods of the parent class (or parent classes in the case of multiple inheritance). Polymorphism allows different classes to use a single method, operator or object, to represent different types in different scenarios; for example, <code>__add__()</code> changes its functionality depending on whether the summed objects are integers, strings or lists.</p> <p>Inheritance leads us to the interesting concept of abstract classes: classes that are meant to be inherited but never instantiated. These abstract classes allow us to define a template with abstract methods that we can later code explicitly in each of its subclasses. To create an abstract class, we subclass Python's Abstract Base Class (ABC), which allows the use of the <code>@abstractmethod</code> decorator to indicate that we left a method undefined on purpose:</p> <p><pre><code>from abc import ABC, abstractmethod\n\n\nclass Shape(ABC):\n\"\"\"Shape abstract class.\"\"\"\n\n    @abstractmethod\n    def area(self):\n\"\"\"Calculate the area of the shape.\"\"\"\n        pass\n\n    def print_area(self):\n\"\"\"Print the area of the shape.\"\"\"\n        print(self.area())\n\n\nclass Square(Shape):\n\"\"\"A square shape.\"\"\"\n\n    def __init__(self, side: float) -&gt; None:\n        self.side = side\n\n    def area(self):\n        return self.side * self.side\n</code></pre> As another example, the <code>linear_map.py</code> module of our library implements the <code>Rotation</code> and <code>Shear</code> transforms as subclasses of the abstract class <code>LinearMap</code>.</p> <p>Tip: improve object-oriented programming applying the SOLID principles.</p> <p>Last but not least, we need to be aware of that Python objects fall into two categories: mutable or immutable. An immutable object is the one that cannot be changed after it is created; even when you think you are changing the object, you are really making new objects from old ones. Immutable objects include numbers, strings, and tuples. Almost everything else is mutable, including lists, dicts, and user-defined objects. Mutable means that the value has methods that can change the value in-place. To learn more about this, check out the example notebook <code>3-mutable-objects.ipynb</code>.</p>"},{"location":"#variables","title":"Variables","text":"<p>A Python variable is a symbolic name that is a reference or pointer to an object. In Python, unlike other programming languages like C, different variables can point to the same object/memory address. Each object has a counter that keeps track of how many variables (names) have been bound to this object. When an object runs out of references, it is no longer accessible and Python will reclaim the allocated memory so it can be used for something else.</p> <p>And how are variables passed to functions? If you have heard about the pass by reference and pass by value paradigms, you may be wondering which one Python follows. Well, the truth is... neither! Python passes variables by assignment; that is, when you call a Python function, each function argument becomes a (local)variable to which the passed object is assigned. Thus, a local and a global variable can point to the same object in memory, with important consequences if the object is mutable.</p> <p>In general, variable names and attributes should follow the <code>lower_case_with_underscores</code> naming convention (as with functions). Only constants defined on a module level should be written in <code>UPPER_CASE_WITH_UNDERSCORES</code>. Variable names should be readable and meaningful, avoiding undescriptive names like single letters or cryptic abbreviations.</p>"},{"location":"#type-hints","title":"Type hints","text":"<p>Python is both a strongly typed and a dynamically typed language. Strongly typed means that the type of an object doesn't change in unexpected ways.</p> <p>In a dynamically typed language, the interpreter does not assign a type to the variable per se because the type can change at runtime. If you ask a variable its type, it will give you the type of the object it is currently assigned to at that moment. Therefore, Python manages memory dynamically, which allows for flexibility in programming, but with a price in performance.</p> <p>Nonetheless, recent versions of Python allow one to add indicative \"static\" type hints to our variables. For example</p> <pre><code>a: int = 3\nb: float = 2.0\n\ndef shouting(text: str) -&gt; str:\n    return text.upper() + \"!!\"\n</code></pre> <p>They can be helpful to make the code clear, create documentation or even catch errors using tools like <code>mypy</code>.</p> <p>More elaborate type hints such as <code>Callable</code> or <code>Sequence</code> can be found in the <code>typing</code> library. Note that, after Python 3.10, the operator <code>|</code> can be used as an \"or\" between different types (same use as <code>Union</code>). For example, this function accepts either a float or an integer and outputs an integer.</p> <pre><code>def float_to_int(variable: float | int) -&gt; int:\n    return int(variable)\n</code></pre>"},{"location":"#docstrings","title":"Docstrings","text":"<p>Quoting Documenting Python Code: A Complete Guide:</p> <p>When you write code, you write it for two primary audiences: your users and your developers (including yourself). Both audiences are equally important. If you\u2019re like me, you\u2019ve probably opened up old codebases and wondered to yourself, \u201cWhat in the world was I thinking?\u201d If you\u2019re having a problem reading your own code, imagine what your users or other developers are experiencing when they\u2019re trying to use or contribute to your code.</p> <p>Probably, at some point in your life, you had to go through \u2014or even worse, work on\u2014 some awful code, so you are hopefully convinced of the necessity of writing clean and well explained code.</p> <p>There are two ways to explain your code: comments and documenting. Comments can be found inside the raw code files and their target audience are developers of the Python code. They can explain a tricky step in an algorithm or a bug fix. That said, ideally, functions should be readable and require few to no inline comments explaining what the code does.</p> <p>Documenting code is describing its use and functionality to your users. While it may be helpful in the development process, the main intended audience is the users. Documentation is often found in a website and inside the code as strings, also known as docstrings.</p> <p>Docstrings should always be added to your modules, classes and functions. The idea when coding is to make simple functions with just one purpose and document them clearly: summarize the function; indicate its arguments, return values and exceptions raised; add notes, examples and references. Remember that we learn better from the concrete, so adding examples to your documentation is always a good idea:</p> <pre><code>\"\"\"\nExamples:\n    Use case of our library:\n\n    &gt;&gt;&gt; some executable code block\n    the result\n\"\"\"\n</code></pre> <p>Note: An easy way to check if the example code gives the expected result without jumping into a jupyter notebook to test it is using the tool <code>doctest</code>, which is part of the standard library. Simply, from the command line, execute</p> <p><pre><code>$ python -m doctest mypackage/linearmap/linear_map.py\n</code></pre> to see the mismatches, if any.</p> <p>These docstrings can follow different conventions; one of the most popular ones is the Google style. I personally like it because it is very clear and compact (Numpy style, in contrast, occupies more lines).</p> <p>To create them in a fast and easy way, I use the autoDocstring extension for VSCode. Once our function is type annotated, we type <code>\"\"\"</code> and click in <code>Generate Docstrings</code>; it will automatically create the template using the annotated inputs and outputs of the function, as well as the exceptions raised.</p>"},{"location":"#tools","title":"Tools","text":""},{"location":"#testing","title":"Testing","text":"<p>How do we know if the functions in our library work as they are supposed to? Sure, we can always have a bunch of jupyter notebooks lying around, but there is a better way: unit testing. Unit testing is a method for testing software that looks at the smallest testable pieces of code, called units, which are tested for correct operation. Usually in Python, units are functions and class methods.</p> <p>Testing is a world on its own, especially in the so-called Test Driven Development (TDD), and we will barely touch the surface in this demo... but it is enough for the needs of most physicists. Just as a sneak peak: we can test how different units fit together (integration testing), test a whole application (system testing), test in different operating systems, etc.</p> <p>The tool we will use for unit testing is <code>pytest</code>. To keep our code organized, outside our library we create another folder called <code>tests</code>. Inside it, we place different modules <code>test_*.py</code>; in our case, we have one for each subpackage: <code>test_vector.py</code> and <code>test_linear_map.py</code>. Inside each of these, we test all the functions and methods in the module (don't forget to test the exceptions as well!). The syntax is really easy, you just need to use the <code>@pytest.mark.parametrize</code> decorator to tell pytest which inputs and expected results you want to test. For example, to assert that 1+2=3 and 3.0-1=2.0:</p> <pre><code>@pytest.mark.parametrize(\n    (\"arg_1\", \"arg_2\", \"result\"),\n    (\n        (1, 2, 3),\n        (3.0, -1, 2.0),\n    ),\n)\ndef test_sum(arg_1, arg_2, result):\n    assert arg_1 + arg_2 == result\n</code></pre> <p>To run all the tests inside the <code>tests</code> folder simply run, from the command line, <pre><code>$ pytest tests\n</code></pre> Or to perform only one test: <pre><code>$ pytest tests/test_vector.py\n</code></pre> If you don't enjoy the command line, the Python extension for VSCode allows us to run the tests easily from a graphic interface.</p> <p>Note: In the workflows section we will see how to automate testing.</p> <p>Tip: sometimes it is easier to test functions generating random inputs and ensuring they fulfill certain properties (called property-based testing or fuzzy testing). This can be done with hypothesis, a library used to test, for example, NumPy.</p>"},{"location":"#debugging","title":"Debugging","text":"<p>How many times have you found yourself adding dozens of <code>print()</code> statements to your code to catch an error? You are not the only one... But turns out there is a much better way: use the debugger in your IDE. You can add breakpoints, execute single lines, see what value each variable has, step into the functions inside your library, see the call stack... A good idea is to debug your tests, since they, ideally, are the final check to see if your code is really working.</p> <p>Note: if you don't have an IDE at hand, you can run, through the command line, The Python Debugger, which is included in the standard library.</p>"},{"location":"#timing","title":"Timing","text":"<p>Even if our code runs without errors, it might not be very useful if it takes too long to do the task. To benchmark our code and find possible bottlenecks, we can use the library <code>timeit</code>, which executes a piece of code a number of times and returns the CPU time taken to run it. As an example, we can run the script <code>7-timing.py</code> to benchmark how long it takes to sum two vectors: <pre><code>$ cd examples\n$ python 7-timing.py\n</code></pre></p> <p>Alternatively, we can use the magic function <code>%timeit</code> inside a jupyter notebook to benchmark a line of code (<code>%%timeit</code> for a cell). You can find an example in <code>5-jit-compiler.ipynb</code>, where we compare the speed of a determinant and its just-in-time compiled version.</p>"},{"location":"#profiling","title":"Profiling","text":"<p>Profiling allows us to disaggregate the time taken to run a function into its different components. For example, when adding two vectors, does it take longer to check that the summand is a vector instance or to actually sum the two vectors? </p> <p>To profile our code we can write a simple script using the <code>Profiler</code> class from the <code>pyinstrument</code> library. To get a sense of how profiling works, you can run the script <code>8-profiling.py</code>: <pre><code>$ cd examples\n$ python 8-profiling.py\n</code></pre></p>"},{"location":"#linting","title":"Linting","text":"<p>Linters like <code>Flake8</code> or <code>Ruff</code> (Ruff is very very fast and implements a lot of checks) help us find mismatches between our code and the conventions stablished by the python community in the PEP8 guidelines. In summary, an indispensable tool for a programmer.</p> <p><code>Ruff</code> can be easily run from the command line to highlight all the errors in our library <pre><code>$ ruff check .\n</code></pre> We can also lint one specific file  <pre><code>$ ruff check mypackage/vector/vector.py\n</code></pre></p> <p><code>Ruff</code>, unlike other linters, also has the option to fix some of the problems encountered in the code <pre><code>$ ruff check --fix mypackage/vector/vector.py\n</code></pre> Unless we are one of those old school programmers that read their email on the terminal, we can avoid using the command line by installing the Ruff extension for VSCode (or whatever tool your IDE provides).</p> <p>You can configure the line lenght, what rules to ignore and other options in the <code>pyproject.toml</code> file. For example,</p> <pre><code>[tool.ruff]\nline-length = 100\nselect = [\"F\", \"E\"]\n</code></pre>"},{"location":"#formatting","title":"Formatting","text":"<p>Keeping track of all the errors and fixing them can be painful... This is where automatic tools to format the code enter. The two most popular are <code>autopep8</code> and <code>black</code>. I prefer <code>black</code> because it requires less configuration. To format our library simply type in the command line <pre><code>$ black mypackage\n</code></pre> Black by default allows a maximum line length of 80. We can tweak this by adding an option: <pre><code>$ black --line-length 100 mypackage\n</code></pre></p> <p>Formatting can be done automatically in VSCode, just add this code to a <code>settings.json</code> file inside a <code>.vscode</code> folder in the main directory <pre><code>{\n\"editor.formatOnSave\": true,\n\"python.formatting.provider\": \"black\",\n\"python.formatting.blackArgs\": [\n\"--line-length\",\n\"100\"\n],\n\"[python]\": {\n\"editor.defaultFormatter\": null,\n\"editor.insertSpaces\": true,\n\"editor.tabSize\": 4,\n\"editor.formatOnSave\": true\n}\n}\n</code></pre></p> <p>As with <code>Ruff</code>, <code>Black</code> configuration is written in the <code>pyproject.toml</code> file:</p> <pre><code>[tool.black]\nline-length = 100\n</code></pre> <p>Tip: install black[jupyter] to format code inside notebooks.</p>"},{"location":"#type-checker","title":"Type checker","text":"<p>The most popular type checker is <code>mypy</code>. Provided that we type hinted our functions and variables, this tool checks any mismatches between the expected input and output types and the actual ones. It can also highlight deeper errors in your code structure, like violations of Liskov substitution principle.</p> <p><pre><code>$ mypy mypackage\n</code></pre> As with all the tools we are using, we can add options for <code>mypy</code> in <code>pyproject.toml</code>:</p> <pre><code>[tool.mypy]\nwarn_return_any = true\nwarn_unused_configs = true\n</code></pre> <p>Note: sometimes it complaints too much so you may just turn it off...</p> <p>Tip: this is not the only use of type annotations. You can also check that the correct types are inputed when innitializing an object with <code>pydantic</code>.</p>"},{"location":"#bit-more-advanced-stuff","title":"Bit more advanced stuff","text":""},{"location":"#code-acceleration","title":"Code acceleration","text":"<p>Python is an interpreted language, which means the source code is executed directly without compiling the program into machine code. It is instead compiled into bytecode (<code>.pyc</code> files), which is run by a Python interpreter. There are multiple interpreters, the most common being CPython, which is programmed in C, but there are options written in Rust (RustPython) and even Python itself (PyPy)!</p> <p>One disadvantage of interpreted languages over compiled ones is that they are slower. But no need to worry, since there is a wide range of tools for accelerating our code:</p> <ul> <li>Just-in-time compilers: Numba, JAX and PyPy (an interpreter with a JIT compiler).</li> <li>Parallelization with <code>pathos.multiprocessing</code> and <code>mpi4py</code> (Message Passing Interface for Python).</li> <li>Extend Python with C code: Cython (the <code>cythonbuilder</code> library makes our life easier).</li> <li>Call Rust functions from Python.</li> </ul> <p>Just-in-time compilers are one the most popular tools in Python nowadays, specially with the increasing interest in the library JAX. You can see a simple example of JIT with Numba in the <code>5-jit-compiler.ipynb</code> notebook.</p>"},{"location":"#installing-the-library","title":"Installing the library","text":"<p>Before we install our local library, we need to specify some metadata and configuration settings; this is done in the <code>pyproject.toml</code> file (check out the setuptools documentation). Then we can use <code>pip</code> with the editable option <code>-e</code> to install our library (where <code>.</code> points to the current \u2014main\u2014 folder):</p> <p><pre><code>$ pip install -e .\n</code></pre> The advantage of installing the local package in editable mode is that, when we make any change, the installed library is updated without reinstalling it.</p> <p>Tip: you can install the library together with the optional dependencies specified in <code>pyproject.toml</code> with <pre><code>$ pip install -e .[dev]\n</code></pre></p>"},{"location":"#creating-documentation","title":"Creating documentation","text":"<p>If you want to create nice looking documentation and then upload it to a website (for free in Github Pages) you can follow this tutorial using <code>mkdocs</code>. As a quick no-brainer guide:</p> <ol> <li> <p>Add a <code>docs</code> folder. Usually, it contains an <code>index.md</code> markdown file that copies whatever you have in the <code>README.md</code> and displays it as the main page of the documentation website. It may also contain additional markdown files that will make different sections of the website (each file is assigned a section in <code>mkdocs.yml</code>).</p> </li> <li> <p>Create a config file <code>mkdocs.yml</code>. You can simply copy the file in this repo and change the basic info like the site's name or URL.</p> </li> <li> <p>To create the documentation for our functions and methods using the docstrings, we use the script <code>gen_ref_nav.py</code>. Inside the script, you only need to change the name of the folder containing your library in the <code>PATH_LIBRARY</code> variable. Again, you can simply copy the docs folder in this repo and modify the script.</p> </li> <li> <p>Add a Github workflow to build and deploy the website in Github Pages. You can just copy the workflow in <code>.github/workflows/documentation.yml</code> (more on workflows later on). Whenever you push changes to Github, the documentation will be updated.</p> </li> <li> <p>(Optional). Before uploading our documentation to the website, we can build it and host it locally on our computer to see the final result. Simply run from the command line <pre><code>$ mkdocs serve --config-file docs/mkdocs.yml\n</code></pre></p> </li> </ol> <p>This repository's documentation can be found in https://pablovegan.github.io/Python-tips-tools/.</p>"},{"location":"#building-and-uploading-to-pypi","title":"Building and uploading to PyPI","text":"<p>When we install packages using <code>pip</code> we are actually downloading them from the PyPI repository (Python Package Index). Anyone can upload packages to PyPI... but be careful, since the package will stay forever in the repository. If you want to play with the uploading process you should always upload the package to https://test.pypi.org/.</p> <p>To upload our library we use the Python package <code>twine</code>. Here is a short guide on how to build and upload our library:</p> <ol> <li>Build our library using <code>setuptools</code> and the <code>pyproject.toml</code> configuration file: <pre><code>$ python -m build\n</code></pre></li> <li>Upload the built library to TestPyPI. You will need to enter the user and password of your TestPyPI account (different from your PyPI account) <pre><code>$ twine upload -r testpypi dist/*\n</code></pre></li> <li>Once you are confident that you want to upload your package to PyPI, use the command <pre><code>$ twine upload dist/*\n</code></pre></li> </ol> <p>Once the package is in PyIP, you can install it in your environment: <pre><code>$ pip install python-tips-tools\n</code></pre> (I only uploaded my package to TestPyPI, since it is not very usefull as a standalone library).</p> <p>Note: the process of uploading the package to PyPI can be automated with a workflow.</p>"},{"location":"#automating-boring-tasks-with-github-workflows","title":"Automating boring tasks with Github workflows","text":"<p>Ordinary tasks in a developer's day such as testing in multiple operating systems and Python versions, releasing packages and uploading them to PyPI, updating the documentation in a website, etc., can all be automated using workflows. Most cloud repositories like Github or Gitlab have them available and are really easy to use (at least the basic ones).</p> <p>In this repo, I added two Github workflows: one to test our library in a linux machine (provided by Github) with Python version 3.10 and another to upload the documentation to Github Pages. The workflows can be found under the folder <code>.github/workflows</code> in <code>*.yml</code> files. As an example, the structure of the <code>test.yml</code> file is:</p> <ol> <li>Apply the action when we git push to the repository.</li> <li>Create an Ubuntu Linux machine with python 3.10 installed.</li> <li>Install <code>pytest</code> as well as the dependencies in the <code>requirements.txt</code> file.</li> <li>Run the tests inside the <code>tests</code> folder using <code>pytest</code>.</li> </ol> <p>The green tick near the commits shows that the workflows were successful.</p> <p></p> <p>Cool tip: we can add a badge at the beginning of our readme to show that the tests either passed or failed (this is updated automatically each time the tests are run).</p>"},{"location":"#command-line-interface","title":"Command line interface","text":"<p>Command line interfaces (CLI) allow us to invoke functions or scripts through the command line without using <code>python -m</code> to execute a module. To do this, we need to create a script contain the CLI (for example, <code>__main__.py</code>) and set it as the entry point in our <code>pyproject.toml</code> file <pre><code>[project.scripts]\nvector = \"mypackage.__main__:main\"\n</code></pre></p> <p>Python's Standard library provides a package to handle command line arguments to create this CLIs: <code>argparse</code>. You can follow along this tutorial to learn how to use it.</p> <p>As an example, we can use the command <code>vector</code> \u2014which calls <code>main()</code> inside <code>__main__.py</code>\u2014 to create and save a vector to a file:</p> <pre><code>$ vector 1 2 --save vector.pkl\nVector (1.0, 2.0) created!\nVector pickled in data/vector.pkl!\n</code></pre>"},{"location":"#other-things-to-look-into","title":"Other things to look into","text":"<ul> <li>List comprehensions. They generally replace lambda functions, <code>map()</code> and <code>filter()</code>.</li> <li>Exception handling: <code>try-except</code> statements. They work very well with custom error classes. An example can be found in the <code>4-exceptions.ipynb</code> notebook inside the <code>examples</code> folder.</li> <li>Iterators and generators: look up the functions <code>iter()</code> and <code>next()</code>, and the keyword <code>yield</code>. Generators are a central feature of Python and they are used in coroutines and context managers.</li> <li>Function and class decorators: decorators are a simple sintax to transform certain functions or classes. An example of an interesting decorator is <code>@classmethod</code>, which allows us, for example, to initialize classes in alternative ways without overly complicating the <code>__init__</code> method.</li> <li>Dataclasses: a concise syntax for classes containing mainly data, similar to structures in C. The library Pydantic implements automatic type checking when initializing a dataclass.</li> <li>Pre-commits: pre-commit hooks allow us to do certain actions before commiting changes with git. For example, we can lint our code with Ruff and fix it with Black whenever we make a commit. </li> <li>Logging: keep a record of what is happening in your program.</li> <li>Literals, keywords and builtins</li> </ul>"},{"location":"#online-resources","title":"Online resources","text":"<p>Most of the material in this repo is covered in the excelent course Python: Coding Guidelines, Tools, Tests and Packages. I also encourage you to watch the sublime talks by James Powell Objectionable Content and So you want to be a Python expert?</p> <p>Of course, free online resources are abundant; to name a few I use frequently: - Real Python - Programiz - Dive into Python 3 - Machine learning mastery - Libraries' documentation</p>"},{"location":"examples/1-vector/","title":"Vector","text":"<p>First things first, if we try to import <code>mypackage</code> from the examples folder, it will fail because Python cannot find it inside <code>examples</code>.</p> In\u00a0[1]: Copied! <pre>import mypackage\n</pre> import mypackage <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 import mypackage\n\nModuleNotFoundError: No module named 'mypackage'</pre> <p>We need to tell Python to search in the parent folder. To do it we just add <code>'..'</code> to the current path.</p> In\u00a0[2]: Copied! <pre>from sys import path\nfrom os.path import abspath\n\n# Tell python to search for the files and modules starting from the working directory\nmodule_path = abspath(\"..\")\nif module_path not in path:\n    path.append(module_path)\n</pre> from sys import path from os.path import abspath  # Tell python to search for the files and modules starting from the working directory module_path = abspath(\"..\") if module_path not in path:     path.append(module_path) <p>Now it works:</p> In\u00a0[3]: Copied! <pre>from mypackage import Vector\n\n# We could also import directly from the subpackage:\n# from mypackage.vector import Vector\n</pre> from mypackage import Vector  # We could also import directly from the subpackage: # from mypackage.vector import Vector <p>Note: If we don't want to be telling Python where to search for our library, we can install it (in editable mode) in our conda environment using</p> <pre>pip install -e .\n</pre> <p>Magic methods in Python are the special methods that start and end with the double underscores. They are also called dunder methods. Magic methods are not meant to be invoked directly by you, but the invocation happens internally from the class on a certain action. For example, when you add two numbers using the + operator, internally, the <code>__add__()</code> method will be called.</p> <p>Let's try some of the methods defined in our class.</p> <p>The <code>__repr__</code> method is called whenever we output an instance of our Vector class. For example:</p> In\u00a0[4]: Copied! <pre>vector = Vector(1, 2)\nvector  # same as repr(vector)\n</pre> vector = Vector(1, 2) vector  # same as repr(vector) Out[4]: <pre>Vector(1, 2)</pre> <p>Printing our vector calls the <code>__str__</code> method inside the vector class, which outputs a string (have a look at the f-strings cheat sheet):</p> In\u00a0[5]: Copied! <pre>print(f\"{vector = !s}\")\n</pre> print(f\"{vector = !s}\") <pre>vector = (1, 2)\n</pre> <p>where <code>!s</code> means to print the result of vector in its string representation.</p> <p>We can sum two vectors with the <code>__add__</code> method</p> In\u00a0[6]: Copied! <pre>vector_1 = Vector(1, 2)\nvector_2 = Vector(3, 4)\n\nprint(f\"{vector_1 + vector_2 = !s}\")\n</pre> vector_1 = Vector(1, 2) vector_2 = Vector(3, 4)  print(f\"{vector_1 + vector_2 = !s}\") <pre>vector_1 + vector_2 = (4, 6)\n</pre> <p>We can multiply vectors with vectors with the <code>__mul__</code> method</p> In\u00a0[7]: Copied! <pre>vector_1 = Vector(1, 2)\nvector_2 = Vector(3, 4)\n\nprint(f\"{vector_1 * vector_2 = }\")\n</pre> vector_1 = Vector(1, 2) vector_2 = Vector(3, 4)  print(f\"{vector_1 * vector_2 = }\") <pre>vector_1 * vector_2 = 11\n</pre> <p>and also a vector times a constant (in this order):</p> In\u00a0[8]: Copied! <pre>vector = Vector(1, 2)\nconstant = 3\n\nprint(f\"{vector * constant = !s}\")\n</pre> vector = Vector(1, 2) constant = 3  print(f\"{vector * constant = !s}\") <pre>vector * constant = (3, 6)\n</pre> <p>But if we multiply a constant times a vector, we get an error because we didn't define a <code>__rmul__</code> method (reverse mutiplication).</p> In\u00a0[9]: Copied! <pre>constant * vector\n</pre> constant * vector <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 constant * vector\n\nTypeError: unsupported operand type(s) for *: 'int' and 'Vector'</pre> <p>We can assert two vectors are equal using the <code>==</code> sign, which in the background calls the magic method <code>__eq__</code>:</p> In\u00a0[10]: Copied! <pre>Vector(1, 1) == Vector(1, 1)\n</pre> Vector(1, 1) == Vector(1, 1) Out[10]: <pre>True</pre> In\u00a0[11]: Copied! <pre>Vector(1, 1) == Vector(2, 1)\n</pre> Vector(1, 1) == Vector(2, 1) Out[11]: <pre>False</pre> <p>Even though <code>norm</code> was defined as a method, since it doesn't take any inputs, we added the <code>@property</code> decorator to treat it as an attribute. That means that we obtain the norm by typing <code>vector.norm</code> instead of <code>vector.norm()</code>.</p> In\u00a0[12]: Copied! <pre>Vector(1, 1).norm\n</pre> Vector(1, 1).norm Out[12]: <pre>1.4142135623730951</pre> <p>And finally we can take the projection of a vector. If no subspace is given, the projection is done along the first component. As you can see, a warning pops up for the forgetful</p> In\u00a0[13]: Copied! <pre>vector = Vector(1, 1)\nvector_projection = vector.projection()\nprint(f\"{vector_projection = !s}\\n\")\n</pre> vector = Vector(1, 1) vector_projection = vector.projection() print(f\"{vector_projection = !s}\\n\") <pre>vector_projection = (1, 0)\n\n</pre> <pre>/var/folders/fg/9xcyj6451md237pczr54fr6c0000gn/T/ipykernel_85478/1694763335.py:2: UserWarning: No subspace given: the vector is projected onto the first component!\n  vector_projection = vector.projection()\n</pre> <p>On the other hand, if the optional argument <code>subspace</code> is given, we project the vector along that subspace:</p> In\u00a0[14]: Copied! <pre>vector = Vector(1, 1)\nvector.projection(Vector(1, 2))\n</pre> vector = Vector(1, 1) vector.projection(Vector(1, 2)) Out[14]: <pre>Vector(0.5999999999999999, 1.1999999999999997)</pre>"},{"location":"examples/1-vector/#using-mypackagevector","title":"Using <code>mypackage.vector</code>\u00b6","text":""},{"location":"examples/1-vector/#importing","title":"Importing\u00b6","text":""},{"location":"examples/1-vector/#vector-methods","title":"Vector methods\u00b6","text":""},{"location":"examples/1-vector/#representation","title":"Representation\u00b6","text":""},{"location":"examples/1-vector/#print","title":"Print\u00b6","text":""},{"location":"examples/1-vector/#addition","title":"Addition\u00b6","text":""},{"location":"examples/1-vector/#multiplication","title":"Multiplication\u00b6","text":""},{"location":"examples/1-vector/#equality","title":"Equality\u00b6","text":""},{"location":"examples/1-vector/#norm-of-the-vector","title":"Norm of the vector\u00b6","text":""},{"location":"examples/1-vector/#projection","title":"Projection\u00b6","text":""},{"location":"examples/2-linear-map/","title":"Linear map","text":"In\u00a0[2]: Copied! <pre>from sys import path\nfrom os.path import abspath\n\n# Tell python to search for the files and modules starting from the working directory\nmodule_path = abspath(\"..\")\nif module_path not in path:\n    path.append(module_path)\n</pre> from sys import path from os.path import abspath  # Tell python to search for the files and modules starting from the working directory module_path = abspath(\"..\") if module_path not in path:     path.append(module_path) <p>Note: If we don't want to be telling Python where to search for our library, we can install it (in editable mode) in our conda environment using</p> <pre>pip install -e .\n</pre> In\u00a0[3]: Copied! <pre>import numpy as np\n\nfrom mypackage import Vector, LinearMap, Rotation, Shear\n</pre> import numpy as np  from mypackage import Vector, LinearMap, Rotation, Shear <p>To make plots, we import matplotlib and adjust the style</p> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.style.use(\"seaborn-whitegrid\")\n</pre> import matplotlib.pyplot as plt  plt.style.use(\"seaborn-whitegrid\") <pre>/var/folders/fg/9xcyj6451md237pczr54fr6c0000gn/T/ipykernel_27868/1055582722.py:3: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use(\"seaborn-whitegrid\")\n</pre> <p>As a first example, we will see what happens if we try to initialize the abstract class <code>LinearMap</code></p> In\u00a0[5]: Copied! <pre>matrix = [[1, 0], [1, 2]]\nmatrix_map = LinearMap(matrix)\n</pre> matrix = [[1, 0], [1, 2]] matrix_map = LinearMap(matrix) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 matrix = [[1, 0], [1, 2]]\n----&gt; 2 matrix_map = LinearMap(matrix)\n\nTypeError: Can't instantiate abstract class LinearMap with abstract method _get_inverse</pre> <p>As we can see, since the method <code>_get_inverse()</code> is not defined, the class cannot be instantiated.</p> <p>On the contrary, there is no problem initializing a <code>Rotation</code> object:</p> In\u00a0[9]: Copied! <pre>angle = np.pi / 4\nrotation = Rotation(angle)\n</pre> angle = np.pi / 4 rotation = Rotation(angle) <p>We can see what happens if we apply this rotation and its inverse to a vector</p> In\u00a0[10]: Copied! <pre>vector = Vector(1, 1)\nrot_vector = rotation(vector)\ninv_rot_vector = rotation.inverse(vector)\n</pre> vector = Vector(1, 1) rot_vector = rotation(vector) inv_rot_vector = rotation.inverse(vector) In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\narrow_kwargs = {\n    \"width\": 0.01,\n    \"head_width\": 0.05,\n    \"length_includes_head\": True,\n}\nax.arrow(0, 0, rot_vector.x, rot_vector.y, color=\"teal\", label=\"rot_vector\", **arrow_kwargs)\nax.arrow(0, 0, vector.x, vector.y, color=\"crimson\", label=\"vector\", **arrow_kwargs)\nax.arrow(\n    0,\n    0,\n    inv_rot_vector.x,\n    inv_rot_vector.y,\n    color=\"goldenrod\",\n    label=\"inv_rot_vector\",\n    **arrow_kwargs,\n)\n\nax.legend(loc=\"lower left\", fontsize=14)\nax.set_title(r\"Rotating a vector an angle $\\pi/4$\", fontsize=16)\nax.set_xlim(-1.5, 1.5)\nax.set_ylim(-1.5, 1.5)\n\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) arrow_kwargs = {     \"width\": 0.01,     \"head_width\": 0.05,     \"length_includes_head\": True, } ax.arrow(0, 0, rot_vector.x, rot_vector.y, color=\"teal\", label=\"rot_vector\", **arrow_kwargs) ax.arrow(0, 0, vector.x, vector.y, color=\"crimson\", label=\"vector\", **arrow_kwargs) ax.arrow(     0,     0,     inv_rot_vector.x,     inv_rot_vector.y,     color=\"goldenrod\",     label=\"inv_rot_vector\",     **arrow_kwargs, )  ax.legend(loc=\"lower left\", fontsize=14) ax.set_title(r\"Rotating a vector an angle $\\pi/4$\", fontsize=16) ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5)  plt.show() <p>In a similar fashion, we can apply a shear transformation and its inverse to a vector</p> In\u00a0[12]: Copied! <pre>angle = np.pi / 4\nshear_map = Shear(angle)\n\nvector = Vector(1, 1)\nshear_vector = shear_map(vector)\ninv_shear_vector = shear_map.inverse(vector)\n</pre> angle = np.pi / 4 shear_map = Shear(angle)  vector = Vector(1, 1) shear_vector = shear_map(vector) inv_shear_vector = shear_map.inverse(vector) In\u00a0[13]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\narrow_kwargs = {\n    \"width\": 0.01,\n    \"head_width\": 0.05,\n    \"length_includes_head\": True,\n}\nax.arrow(0, 0, shear_vector.x, shear_vector.y, color=\"teal\", label=\"shear_vector\", **arrow_kwargs)\nax.arrow(0, 0, vector.x, vector.y, color=\"crimson\", label=\"vector\", **arrow_kwargs)\nax.arrow(\n    0,\n    0,\n    inv_shear_vector.x,\n    inv_shear_vector.y,\n    color=\"goldenrod\",\n    label=\"inv_shear_vector\",\n    **arrow_kwargs,\n)\n\nax.legend(loc=\"lower left\", fontsize=14)\nax.set_title(r\"Rotating a vector an angle $\\pi/4$\", fontsize=16)\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) arrow_kwargs = {     \"width\": 0.01,     \"head_width\": 0.05,     \"length_includes_head\": True, } ax.arrow(0, 0, shear_vector.x, shear_vector.y, color=\"teal\", label=\"shear_vector\", **arrow_kwargs) ax.arrow(0, 0, vector.x, vector.y, color=\"crimson\", label=\"vector\", **arrow_kwargs) ax.arrow(     0,     0,     inv_shear_vector.x,     inv_shear_vector.y,     color=\"goldenrod\",     label=\"inv_shear_vector\",     **arrow_kwargs, )  ax.legend(loc=\"lower left\", fontsize=14) ax.set_title(r\"Rotating a vector an angle $\\pi/4$\", fontsize=16) ax.set_xlim(-2, 2) ax.set_ylim(-2, 2)  plt.show()"},{"location":"examples/2-linear-map/#using-mypackagelinearmap","title":"Using <code>mypackage.linearmap</code>\u00b6","text":""},{"location":"examples/2-linear-map/#importing","title":"Importing\u00b6","text":""},{"location":"examples/2-linear-map/#transforming-vectors","title":"Transforming vectors\u00b6","text":""},{"location":"examples/3-mutable-objects/","title":"Mutable objects","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np <p>A Python variable is a symbolic name that is a reference or pointer to an object. To analyze whether two variables refer to the same object, we can use the <code>id()</code> function, which returns a unique identification number of the object stored in memory. This will be helpful to see which objects can be changed in-place \u2014i.e. mutable objects\u2014 and which cannot.</p> In\u00a0[2]: Copied! <pre>var = 'Howdy!'\nprint(f\"The id of var is {id(var)}\")\nprint(f\"The id of var in hexadecimal format is {hex(id(var))}\")\n</pre> var = 'Howdy!' print(f\"The id of var is {id(var)}\") print(f\"The id of var in hexadecimal format is {hex(id(var))}\") <pre>The id of var is 140456188344176\nThe id of var in hexadecimal format is 0x7fbe81367770\n</pre> <p>An immutable object is one that cannot be changed after it is created; even when you think you are changing the object, you are really making new objects from old ones. Immutable objects include numbers, strings, and tuples.</p> <p>For example, if we define an integer and make an in-place sum, the object changes and so does the id</p> In\u00a0[3]: Copied! <pre>a: int = 1\nprint(f\"The id of a is {hex(id(a))}\")\n\na += 1\nprint(f\"The id of a is {hex(id(a))}\")\n</pre> a: int = 1 print(f\"The id of a is {hex(id(a))}\")  a += 1 print(f\"The id of a is {hex(id(a))}\") <pre>The id of a is 0x7fbe7e8380f0\nThe id of a is 0x7fbe7e838110\n</pre> <p>We can also see what happens if we assign the same object to two different variables and change one of them. At the beginning both variables point to the same address</p> In\u00a0[4]: Copied! <pre>a: int = 1\nb = a\nprint(f\"The id of a is {hex(id(a))}\")\nprint(f\"The id of b is {hex(id(b))}\")\n</pre> a: int = 1 b = a print(f\"The id of a is {hex(id(a))}\") print(f\"The id of b is {hex(id(b))}\") <pre>The id of a is 0x7fbe7e8380f0\nThe id of b is 0x7fbe7e8380f0\n</pre> <p>but, as soon as we change <code>b</code>, a new object is created and now <code>b</code> points to a different object</p> In\u00a0[5]: Copied! <pre>b += 1\nprint(f\"{a = }\")\nprint(f\"{b = }\")\nprint(f\"\\nThe id of a is {hex(id(a))}\")\nprint(f\"The id of b is {hex(id(b))}\")\n</pre> b += 1 print(f\"{a = }\") print(f\"{b = }\") print(f\"\\nThe id of a is {hex(id(a))}\") print(f\"The id of b is {hex(id(b))}\") <pre>a = 1\nb = 2\n\nThe id of a is 0x7fbe7e8380f0\nThe id of b is 0x7fbe7e838110\n</pre> <p>Almost everything else is mutable, including lists, dictionaries and user-defined objects. Mutable means that the value has methods that can change the value in-place.</p> <p>Lists are the paradigmatic example of mutable objects. We can repeat the steps we did in the integer example to see the differences. We begin with an in-inplace sum and, this time, the object's id doesn't change</p> In\u00a0[6]: Copied! <pre>list_a: list[int] = [1]\nprint(f\"The id of list_a is {hex(id(list_a))}\")\n\nlist_a += [2]  # equivalent to list_a.append(2)\nprint(f\"The id of list_a is {hex(id(list_a))}\")\n</pre> list_a: list[int] = [1] print(f\"The id of list_a is {hex(id(list_a))}\")  list_a += [2]  # equivalent to list_a.append(2) print(f\"The id of list_a is {hex(id(list_a))}\") <pre>The id of list_a is 0x7fbe813cf740\nThe id of list_a is 0x7fbe813cf740\n</pre> <p>Note: beware that if we didn't do an in-place sum but an ordinary sum, a new object would be created.</p> In\u00a0[7]: Copied! <pre>list_a = [1]\nprint(f\"The id of list_a is {hex(id(list_a))}\")\n\nlist_a = list_a + [2]\nprint(f\"The id of list_a is {hex(id(list_a))}\")\n</pre> list_a = [1] print(f\"The id of list_a is {hex(id(list_a))}\")  list_a = list_a + [2] print(f\"The id of list_a is {hex(id(list_a))}\") <pre>The id of list_a is 0x7fbe813b2a00\nThe id of list_a is 0x7fbe813cf740\n</pre> <p>Finally, we show that if two variables point to the same mutable object, any change in the object affects both variables (compare this with the <code>int</code> example)</p> In\u00a0[8]: Copied! <pre>list_a = [1]\nlist_b = list_a\nlist_b.append(2)\n\nprint(f\"{list_a = }\")\nprint(f\"{list_b = }\")\n</pre> list_a = [1] list_b = list_a list_b.append(2)  print(f\"{list_a = }\") print(f\"{list_b = }\") <pre>list_a = [1, 2]\nlist_b = [1, 2]\n</pre> <p>As a final example (and warning), an essential feature in Python is that values are passed to functions by assignment. As a consequence, functions can modify global mutable objects even when, apparently, they are just local variables inside the function (local variables are destroyed when the function ends).</p> In\u00a0[9]: Copied! <pre>def list_append(value, local_list: list) -&gt; None:\n    local_list.append(value)  # list modified\n</pre> def list_append(value, local_list: list) -&gt; None:     local_list.append(value)  # list modified In\u00a0[10]: Copied! <pre>global_list = [1]\nlist_append(2, global_list)\nglobal_list\n</pre> global_list = [1] list_append(2, global_list) global_list Out[10]: <pre>[1, 2]</pre> <p>This happens because the (local) variable <code>local_list</code> gets assigned the same object as the (global) variable <code>global_list</code>. Since both point to the same mutable object, changes in <code>local_list</code> will change the object itself, thus changing the object that <code>global_list</code> is referencing.</p> <p>But, what happens if <code>local_list</code> creates a new object? Then <code>local_list</code> is going to point to a new (local) object and the changes will not affect <code>global_list</code>.</p> In\u00a0[11]: Copied! <pre>def list_append(value, local_list: list) -&gt; None:\n    local_list = local_list + [value]  # new list created\n</pre> def list_append(value, local_list: list) -&gt; None:     local_list = local_list + [value]  # new list created In\u00a0[12]: Copied! <pre>global_list = [1]\nlist_append(2, global_list)\nglobal_list\n</pre> global_list = [1] list_append(2, global_list) global_list Out[12]: <pre>[1]</pre> <p>And what if <code>local_list</code> has a default value? Since the line</p> <pre>def list_append(value, local_list = [1]):\n</pre> <p>is executed only once, <code>local_list</code> is assigned the default value <code>[1]</code> when we define the function, not everytime we execute it. So we must be careful: if the object is mutable and we modify it, it will change from one execution to another!</p> In\u00a0[13]: Copied! <pre>def list_append(value, local_list: list = [1]) -&gt; None:\n    local_list.append(value)\n    print(f\"local_list = {local_list}\")\n</pre> def list_append(value, local_list: list = [1]) -&gt; None:     local_list.append(value)     print(f\"local_list = {local_list}\") In\u00a0[14]: Copied! <pre>list_append(2)\nlist_append(3)\n</pre> list_append(2) list_append(3) <pre>local_list = [1, 2]\nlocal_list = [1, 2, 3]\n</pre> <p>We can fix this pathological behaviour just by creating a new local list instead of modifying it:</p> In\u00a0[15]: Copied! <pre>def list_append(value, local_list: list = [1]) -&gt; None:\n    local_list = local_list + [value]\n    print(f\"local_list = {local_list}\")\n</pre> def list_append(value, local_list: list = [1]) -&gt; None:     local_list = local_list + [value]     print(f\"local_list = {local_list}\") In\u00a0[16]: Copied! <pre>list_append(2)\nlist_append(3)\n</pre> list_append(2) list_append(3) <pre>local_list = [1, 2]\nlocal_list = [1, 3]\n</pre> <p>If we wanted to initialize a function (or a class) with a default mutable argument, we should set the default value to <code>None</code></p> <pre>def __init__(list_: list | None = None):\n    if list_ is None:\n        list_ = []\n    ...\n</pre>"},{"location":"examples/3-mutable-objects/#mutable-and-immutable-types","title":"Mutable and immutable types\u00b6","text":""},{"location":"examples/3-mutable-objects/#imports","title":"Imports\u00b6","text":""},{"location":"examples/3-mutable-objects/#the-id-function","title":"The <code>id()</code> function\u00b6","text":""},{"location":"examples/3-mutable-objects/#immutable-objects","title":"Immutable objects\u00b6","text":""},{"location":"examples/3-mutable-objects/#mutable-objects","title":"Mutable objects\u00b6","text":""},{"location":"examples/3-mutable-objects/#functions-and-references","title":"Functions and references\u00b6","text":""},{"location":"examples/4-exceptions/","title":"Exceptions","text":"In\u00a0[1]: Copied! <pre>from sys import path\nfrom os.path import abspath\n\n# Tell python to search for the files and modules starting from the working directory\nmodule_path = abspath(\"..\")\nif module_path not in path:\n    path.append(module_path)\n</pre> from sys import path from os.path import abspath  # Tell python to search for the files and modules starting from the working directory module_path = abspath(\"..\") if module_path not in path:     path.append(module_path) <p>Note: If we don't want to be telling Python where to search for our library, we can install it (in editable mode) in our conda environment using</p> <pre>pip install -e .\n</pre> In\u00a0[2]: Copied! <pre>from mypackage import Vector\n</pre> from mypackage import Vector <p>Exception errors occur whenever syntactically correct Python code results in an error. In our <code>Vector</code> class, we raised an error whenever the norm of the initialized vector was greater than the module constant <code>MAX_NORM</code>. This custom error class, <code>NormError</code>, was defined as a subclass of the built-in exception class <code>ValueError</code>.</p> In\u00a0[3]: Copied! <pre>vector = Vector(100, 200)\n</pre> vector = Vector(100, 200) <pre>\n---------------------------------------------------------------------------\nNormError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 vector = Vector(100, 200)\n\nFile ~/Documents/Code projects/Python-tips-tools/mypackage/vector/vector.py:70, in Vector.__init__(self, x, y)\n     67 self.y: float = y\n     69 if self.norm &gt; MAX_NORM:\n---&gt; 70     raise NormError(self.norm)\n\nNormError: Norm = 223.60679774997897, but it cannot be greater than 100.</pre> <p>Custom exceptions come in handy when handling errors. For example, we can create a vector given two components and, in case the norm is too big, handle the <code>NormError</code> to create a new \"renormalized\" vector</p> In\u00a0[5]: Copied! <pre>from mypackage import NormError\n\nx = 100\ny = 200\n\ntry:\n    vector = Vector(x, y)\n    print(f\"{vector = !s}\")\n\nexcept NormError:\n    print(\"Norm is too big, resizing the vector...\")\n    x = x % 71\n    y = y % 71\n    vector = Vector(x, y)\n    print(f\"{vector = !s}\")\n\nfinally:\n    print(\"\\nThe try-except statement ended!\")\n</pre> from mypackage import NormError  x = 100 y = 200  try:     vector = Vector(x, y)     print(f\"{vector = !s}\")  except NormError:     print(\"Norm is too big, resizing the vector...\")     x = x % 71     y = y % 71     vector = Vector(x, y)     print(f\"{vector = !s}\")  finally:     print(\"\\nThe try-except statement ended!\") <pre>Norm is too big, resizing the vector...\nvector = (29, 58)\n\nThe try-except statement ended!\n</pre>"},{"location":"examples/4-exceptions/#exception-handling-tutorial","title":"Exception handling tutorial\u00b6","text":""},{"location":"examples/4-exceptions/#imports","title":"Imports\u00b6","text":""},{"location":"examples/4-exceptions/#custom-exceptions","title":"Custom exceptions\u00b6","text":""},{"location":"examples/4-exceptions/#exception-handling","title":"Exception handling\u00b6","text":""},{"location":"examples/5-jit-compiler/","title":"Jit compiler","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom numpy.typing import NDArray\nimport numba\n</pre> import numpy as np from numpy.typing import NDArray import numba <p>Numba is a just-in-time compiler for Python that works best on code that uses NumPy arrays, Numpy functions, and loops. When a call is made to a Numba decorated function (with <code>@numba.jit()</code>) it is compiled to machine code \u201cjust-in-time\u201d for execution and all or part of your code can subsequently run at native machine code speed!</p> <p>Thus, using Numba inside Python classes or with Python objects like DataFrames is not very useful... It is better to use it with standalone functions that do mainly numerical calculations.</p> In\u00a0[2]: Copied! <pre>def determinant(matrix: NDArray) -&gt; float:\n\"\"\"Calculate the determinant of a matrix.\n\n    Args:\n        matrix (np.ndarray): a square matrix.\n\n    Returns:\n        float: the determinant of matrix.\n    \"\"\"\n    # Check the ndarray is a square matrix\n    assert len(matrix.shape) == 2\n    assert matrix.shape[0] == matrix.shape[1]\n\n    dim = matrix.shape[0]\n\n    # Convert the matrix to upper triangular form\n    for col in range(0, dim - 1):\n        for row in range(col + 1, dim):\n            if matrix[row, col] != 0.0:\n                coef = matrix[row, col] / matrix[col, col]\n                matrix[row, col:dim] = matrix[row, col:dim] - coef * matrix[col, col:dim]\n\n    return np.prod(np.diag(matrix))\n</pre> def determinant(matrix: NDArray) -&gt; float:     \"\"\"Calculate the determinant of a matrix.      Args:         matrix (np.ndarray): a square matrix.      Returns:         float: the determinant of matrix.     \"\"\"     # Check the ndarray is a square matrix     assert len(matrix.shape) == 2     assert matrix.shape[0] == matrix.shape[1]      dim = matrix.shape[0]      # Convert the matrix to upper triangular form     for col in range(0, dim - 1):         for row in range(col + 1, dim):             if matrix[row, col] != 0.0:                 coef = matrix[row, col] / matrix[col, col]                 matrix[row, col:dim] = matrix[row, col:dim] - coef * matrix[col, col:dim]      return np.prod(np.diag(matrix)) <p>The behaviour of the <code>nopython=True</code> compilation mode is to essentially compile the decorated function so that it will run entirely without the involvement of the Python interpreter. This is the recommended and best-practice way to use the Numba jit decorator as it leads to the best performance.</p> In\u00a0[3]: Copied! <pre>@numba.jit(nopython=True)\ndef jit_determinant(matrix: NDArray) -&gt; float:\n\"\"\"Calculate the determinant of a matrix faster using a just in time compiler.\n    The behaviour of the `nopython=True` compilation mode is to essentially compile the decorated\n    function so that it will run entirely without the involvement of the Python interpreter.\n\n    Args:\n        matrix (np.ndarray): a square matrix.\n\n    Returns:\n        float: the determinant of matrix.\n    \"\"\"\n    # Check the ndarray is a square matrix\n    assert len(matrix.shape) == 2\n    assert matrix.shape[0] == matrix.shape[1]\n\n    dim = matrix.shape[0]\n\n    # Convert the matrix to upper triangular form\n    for col in range(0, dim - 1):\n        for row in range(col + 1, dim):\n            if matrix[row, col] != 0.0:\n                coef = matrix[row, col] / matrix[col, col]\n                matrix[row, col:dim] = matrix[row, col:dim] - coef * matrix[col, col:dim]\n\n    return np.prod(np.diag(matrix))\n</pre> @numba.jit(nopython=True) def jit_determinant(matrix: NDArray) -&gt; float:     \"\"\"Calculate the determinant of a matrix faster using a just in time compiler.     The behaviour of the `nopython=True` compilation mode is to essentially compile the decorated     function so that it will run entirely without the involvement of the Python interpreter.      Args:         matrix (np.ndarray): a square matrix.      Returns:         float: the determinant of matrix.     \"\"\"     # Check the ndarray is a square matrix     assert len(matrix.shape) == 2     assert matrix.shape[0] == matrix.shape[1]      dim = matrix.shape[0]      # Convert the matrix to upper triangular form     for col in range(0, dim - 1):         for row in range(col + 1, dim):             if matrix[row, col] != 0.0:                 coef = matrix[row, col] / matrix[col, col]                 matrix[row, col:dim] = matrix[row, col:dim] - coef * matrix[col, col:dim]      return np.prod(np.diag(matrix)) <p>As we can see, the jit compiled determinant is much faster than the interpreted version:</p> In\u00a0[5]: Copied! <pre>matrix = np.random.randn(40, 40)\n\nprint(\"Timing the basic determinant:\")\n%timeit determinant(matrix)\n\nprint(\"\\nTiming the JIT determinant:\")\n%timeit jit_determinant(matrix)\n</pre> matrix = np.random.randn(40, 40)  print(\"Timing the basic determinant:\") %timeit determinant(matrix)  print(\"\\nTiming the JIT determinant:\") %timeit jit_determinant(matrix) <pre>Timing the basic determinant:\n300 \u00b5s \u00b1 2.06 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n\nTiming the JIT determinant:\n17 \u00b5s \u00b1 298 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</pre>"},{"location":"examples/5-jit-compiler/#accelerating-code-with-numba","title":"Accelerating code with Numba\u00b6","text":""},{"location":"examples/5-jit-compiler/#imports","title":"Imports\u00b6","text":""},{"location":"examples/5-jit-compiler/#numba-and-jit","title":"Numba and JIT\u00b6","text":""},{"location":"examples/5-jit-compiler/#example-the-determinant","title":"Example: the determinant\u00b6","text":""},{"location":"examples/5-jit-compiler/#timing","title":"Timing\u00b6","text":""},{"location":"reference/","title":"mypackage","text":""},{"location":"reference/#mypackage","title":"<code>mypackage</code>","text":""},{"location":"reference/_version/","title":"_version","text":""},{"location":"reference/_version/#mypackage._version","title":"<code>mypackage._version</code>","text":"<p>Version number (major.minor.patch)</p>"},{"location":"reference/linearmap/","title":"linearmap","text":""},{"location":"reference/linearmap/#mypackage.linearmap","title":"<code>mypackage.linearmap</code>","text":"<p>To import from the vector.py module we can also type from .linear_transform import Rotation, Shear</p>"},{"location":"reference/linearmap/linear_map/","title":"linear_map","text":""},{"location":"reference/linearmap/linear_map/#mypackage.linearmap.linear_map","title":"<code>mypackage.linearmap.linear_map</code>","text":"<p>This module contains the LinearMap abstract class and two subclasses: Rotation and Shear.</p> <p>Examples:</p> <p>We can define a rotation linear map and then apply the transformation to a vector as if it were a function:</p> <pre><code>&gt;&gt;&gt; angle = 0.5\n&gt;&gt;&gt; map = Rotation(angle)\n&gt;&gt;&gt; map(Vector(1, 0))\nVector(0.8775825618903728, 0.479425538604203)\n</code></pre> <p>And with the inverse method, we can apply the inverse transformation</p> <pre><code>&gt;&gt;&gt; shear_angle = 0.5\n&gt;&gt;&gt; map = Shear(shear_angle)\n&gt;&gt;&gt; map.inverse(Vector(1, 1))\nVector(-0.830487721712452, 1)\n</code></pre>"},{"location":"reference/linearmap/linear_map/#mypackage.linearmap.linear_map.LinearMap","title":"<code>LinearMap(matrix)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>This abstract class will serve us as a base for other linear maps that we will later especify in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>list[list[float]]</code> <p>matrix of our linear map. It consists on a list of rows, each row being a list of the numbers in each column.</p> required <p>Attributes:</p> Name Type Description <code>matrix</code> <code>list[list[float]]</code> <p>the matrix of our linear map.</p> <code>inv_matrix</code> <code>list[list[float]]</code> <p>the matrix of the inverse of our linear map.</p> Source code in <code>mypackage/linearmap/linear_map.py</code> <pre><code>def __init__(self, matrix: list[list[float]]) -&gt; None:\n    self.matrix = matrix\n    self.inv_matrix = self._get_inverse()  # we can call an undefined abstract method\n</code></pre>"},{"location":"reference/linearmap/linear_map/#mypackage.linearmap.linear_map.LinearMap.__call__","title":"<code>__call__(vector)</code>","text":"<p>Apply the linear map to a vector (which translates into ordinary matrix times vector multiplication).</p> Note <p>The call method allows an instance of this class to behave as a function.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Vector</code> <p>Vector to map.</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <code>Vector</code> <p>Transformed vector.</p> Source code in <code>mypackage/linearmap/linear_map.py</code> <pre><code>def __call__(self, vector: Vector) -&gt; Vector:\n\"\"\"Apply the linear map to a vector (which translates into ordinary matrix\n    times vector multiplication).\n\n    Note:\n        The call method allows an instance of this class to behave as a function.\n\n    Args:\n        vector (Vector): Vector to map.\n\n    Returns:\n        Vector: Transformed vector.\n    \"\"\"\n    x = self.matrix[0][0] * vector.x + self.matrix[0][1] * vector.y\n    y = self.matrix[1][0] * vector.x + self.matrix[1][1] * vector.y\n    return Vector(x, y)\n</code></pre>"},{"location":"reference/linearmap/linear_map/#mypackage.linearmap.linear_map.LinearMap.inverse","title":"<code>inverse(vector)</code>","text":"<p>Apply the inverse of our map to a vector.</p> Note <p>When giving a name to a method, you should take into account how would you name an instance of this class. For example, if we create an instance called 'rotation', it is very clear to read <code>rotation.inverse(some_vector)</code> and guess that it applies the inverse rotation to the vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Vector</code> <p>Vector to transform.</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <code>Vector</code> <p>Transformed vector.</p> Source code in <code>mypackage/linearmap/linear_map.py</code> <pre><code>def inverse(self, vector: Vector) -&gt; Vector:\n\"\"\"Apply the inverse of our map to a vector.\n\n    Note:\n        When giving a name to a method, you should take into account how would\n        you name an instance of this class. For example, if we create an instance\n        called 'rotation', it is very clear to read `rotation.inverse(some_vector)`\n        and guess that it applies the inverse rotation to the vector.\n\n    Args:\n        vector (Vector): Vector to transform.\n\n    Returns:\n        Vector: Transformed vector.\n    \"\"\"\n    x = self.inv_matrix[0][0] * vector.x + self.inv_matrix[0][1] * vector.y\n    y = self.inv_matrix[1][0] * vector.x + self.inv_matrix[1][1] * vector.y\n    return Vector(x, y)\n</code></pre>"},{"location":"reference/linearmap/linear_map/#mypackage.linearmap.linear_map.Rotation","title":"<code>Rotation(angle)</code>","text":"<p>             Bases: <code>LinearMap</code></p> <p>Two dimensional rotation of a certain angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>angle of the rotation.</p> required <p>Attributes:</p> Name Type Description <code>angle</code> <code>float</code> <p>angle of the rotation.</p> Source code in <code>mypackage/linearmap/linear_map.py</code> <pre><code>def __init__(self, angle: float) -&gt; None:\n    self.angle = angle\n    matrix = [[cos(angle), -sin(angle)], [sin(angle), cos(angle)]]\n    super().__init__(matrix)\n</code></pre>"},{"location":"reference/linearmap/linear_map/#mypackage.linearmap.linear_map.Shear","title":"<code>Shear(shear_angle)</code>","text":"<p>             Bases: <code>LinearMap</code></p> <p>Shear transformation parallel to the x axis.</p> <p>Parameters:</p> Name Type Description Default <code>shear_angle</code> <code>float</code> <p>angle of the shear transformation.</p> required <p>Attributes:</p> Name Type Description <code>shear_factor</code> <code>float</code> <p>cotangent of the shear angle.</p> Source code in <code>mypackage/linearmap/linear_map.py</code> <pre><code>def __init__(self, shear_angle: float) -&gt; None:\n    self.shear_factor = 1 / tan(shear_angle)  # shear factor is the cotangent of the shear angle\n    matrix = [[1, self.shear_factor], [0, 1]]\n    super().__init__(matrix)\n</code></pre>"},{"location":"reference/vector/","title":"vector","text":""},{"location":"reference/vector/#mypackage.vector","title":"<code>mypackage.vector</code>","text":"<p>To import from the vector.py module we can also type from mylibrary.vector.vector import Vector2D, NormError</p>"},{"location":"reference/vector/vector/","title":"vector","text":""},{"location":"reference/vector/vector/#mypackage.vector.vector","title":"<code>mypackage.vector.vector</code>","text":"<p>This module contains the Vector class and the NormError exception.</p> <p>Attributes:</p> Name Type Description <code>MAX_NORM</code> <code>float</code> <p>Maximum norm allowed for a Vector instance.</p> Note <p>Imports should follow always the same order:     import python_standard_library</p> <pre><code>import third_party_libraries\n\nimport local_librariess\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.NormError","title":"<code>NormError(norm)</code>","text":"<p>             Bases: <code>ValueError</code></p> <p>Exception raised when a vector's norm is greater than MAX_NORM.</p> Note <p>Custom exception classes are very useful for exception handling.</p> <p>Parameters:</p> Name Type Description Default <code>norm</code> <code>float</code> <p>The norm of the vector.</p> required <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The message to display when the exception is raised.</p> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __init__(self, norm: float) -&gt; None:\n    message = f\"Norm = {norm}, but it cannot be greater than {MAX_NORM}.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector","title":"<code>Vector(x, y)</code>","text":"<p>Two dimensional vector.</p> Note <p>Remember that class docstrings in Google format should contain the arguments of the init method and the attributes of the class, but not the methods.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>first component of the vector.</p> required <code>y</code> <code>float</code> <p>second component of the vector.</p> required <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>first component of the vector.</p> <code>y</code> <code>float</code> <p>second component of the vector.</p> <p>Raises:</p> Type Description <code>NormError</code> <p>the norm of the vector is greater than MAX_NORM.</p> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __init__(self, x: float, y: float) -&gt; None:\n    self.x: float = x\n    self.y: float = y\n\n    if self.norm &gt; MAX_NORM:\n        raise NormError(self.norm)\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.norm","title":"<code>norm: float</code>  <code>property</code>","text":"<p>Returns the Euclidean norm of the vector.</p> Note <p>Since the method doesn't accept any input, we can treat it as an attribute. To do that we just have to add the @property decorator on top of the method.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the euclidean norm of the vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vector = Vector(1,0)\n&gt;&gt;&gt; vector.norm\n1.0\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.__add__","title":"<code>__add__(other_vector)</code>","text":"<p>Returns the addition vector of self and the other vector.</p> <p>Parameters:</p> Name Type Description Default <code>other_vector</code> <code>Vector</code> <p>Other vector (right hand side).</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Not Vector passed in.</p> <p>Returns:</p> Type Description <code>Vector</code> <p>The addition vector of self and the other vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Vector(1, 0) + Vector(0, 1)\nVector(1, 1)\n</code></pre> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __add__(self, other_vector: Vector) -&gt; Vector:\n\"\"\"Returns the addition vector of self and the other vector.\n\n    Args:\n        other_vector: Other vector (right hand side).\n\n    Raises:\n        TypeError: Not Vector passed in.\n\n    Returns:\n        The addition vector of self and the other vector.\n\n    Examples:\n\n        &gt;&gt;&gt; Vector(1, 0) + Vector(0, 1)\n        Vector(1, 1)\n\n    \"\"\"\n    if not isinstance(other_vector, Vector):\n        raise TypeError(\"You must pass in a Vector instance!\")\n    x = self.x + other_vector.x\n    y = self.y + other_vector.y\n    return Vector(x, y)\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.__eq__","title":"<code>__eq__(other_vector)</code>","text":"<p>Check if the vectors have the same values up to some tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>other_vector</code> <code>object</code> <p>Other vector (right hand side).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True, if both vectors have the same values.</p> <code>bool</code> <p>False, else.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Vector(1, 0) == Vector(2, 0)\nFalse\n</code></pre> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __eq__(self, other_vector: object) -&gt; bool:\n\"\"\"Check if the vectors have the same values up to some tolerance.\n\n    Args:\n        other_vector: Other vector (right hand side).\n\n    Returns:\n        True, if both vectors have the same values.\n        False, else.\n\n    Examples:\n\n        &gt;&gt;&gt; Vector(1, 0) == Vector(2, 0)\n        False\n\n    \"\"\"\n    if not isinstance(other_vector, Vector):\n        return False\n    # math.isclose returns true if the numbers are equal up to a small error\n    equal_x: bool = math.isclose(self.x, other_vector.x, abs_tol=1e-10)\n    equal_y: bool = math.isclose(self.y, other_vector.y, abs_tol=1e-10)\n    return equal_x and equal_y\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return the multiplication of self and the other vector/number.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector | float</code> <p>Other vector or scalar value (right hand side).</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Not int/float passed in.</p> <p>Returns:</p> Type Description <code>Vector | float</code> <p>The multiplication of self and the other vector/number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Vector(1, 0) * 4\nVector(4, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; Vector(1, 0) * Vector(1, 1)\n1\n</code></pre> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __mul__(self, other: Vector | float) -&gt; Vector | float:\n\"\"\"Return the multiplication of self and the other vector/number.\n\n    Args:\n        other: Other vector or scalar value (right hand side).\n\n    Raises:\n        TypeError: Not int/float passed in.\n\n    Returns:\n        The multiplication of self and the other vector/number.\n\n    Examples:\n\n        &gt;&gt;&gt; Vector(1, 0) * 4\n        Vector(4, 0)\n\n        &gt;&gt;&gt; Vector(1, 0) * Vector(1, 1)\n        1\n\n    \"\"\"\n    if isinstance(other, Vector):\n        return self.x * other.x + self.y * other.y\n\n    if not isinstance(other, int | float):\n        raise TypeError(\"You must pass in an int/float!\")\n\n    return Vector(self.x * other, self.y * other)\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the vector representation.</p> Note <p>The idea behind representations is that, when we execute the output of this function, we should create an identical copy of this object.</p> <p>Returns:</p> Type Description <code>str</code> <p>The representation of the vector.</p> <p>Examples:</p> <p>We type the following to output the vector representation:</p> <pre><code>&gt;&gt;&gt; vector = Vector(1, 2)\n&gt;&gt;&gt; vector\nVector(1, 2)\n</code></pre> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return the vector representation.\n\n    Note:\n        The idea behind representations is that, when we execute the output of this\n        function, we should create an identical copy of this object.\n\n    Returns:\n        The representation of the vector.\n\n    Examples:\n        We type the following to output the vector representation:\n\n        &gt;&gt;&gt; vector = Vector(1, 2)\n        &gt;&gt;&gt; vector\n        Vector(1, 2)\n\n    \"\"\"\n    return f\"Vector({self.x}, {self.y})\"\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.__str__","title":"<code>__str__()</code>","text":"<p>This method is called when we want to print our vector as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The vector instance as a string.</p> <p>Examples:</p> <p>To call str simply type</p> <pre><code>&gt;&gt;&gt; vector = Vector(1, 2)\n&gt;&gt;&gt; print(vector)\n(1, 2)\n</code></pre> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"This method is called when we want to print our vector as a string.\n\n    Returns:\n        The vector instance as a string.\n\n    Examples:\n        To call __str__ simply type\n\n        &gt;&gt;&gt; vector = Vector(1, 2)\n        &gt;&gt;&gt; print(vector)\n        (1, 2)\n\n    \"\"\"\n    return f\"({self.x}, {self.y})\"\n</code></pre>"},{"location":"reference/vector/vector/#mypackage.vector.vector.Vector.projection","title":"<code>projection(subspace=None)</code>","text":"<p>By default projects the vector onto its first component. If a vector spanning a subspace is given, then the vector is projected along this subspace.</p> <p>Parameters:</p> Name Type Description Default <code>subspace</code> <code>Vector</code> <p>vector that spans the subspace onto which to project the vector. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Vector</code> <code>Vector</code> <p>The projected vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Vector(1,1).projection(Vector(0,1))\nVector(0.0, 1.0)\n</code></pre> Source code in <code>mypackage/vector/vector.py</code> <pre><code>def projection(self, subspace: Vector | None = None) -&gt; Vector:\n\"\"\"By default projects the vector onto its first component. If a vector spanning\n    a subspace is given, then the vector is projected along this subspace.\n\n    Args:\n        subspace (Vector, optional): vector that spans the subspace onto which to project\n            the vector. Defaults to None.\n\n    Returns:\n        Vector: The projected vector.\n\n    Examples:\n        &gt;&gt;&gt; Vector(1,1).projection(Vector(0,1))\n        Vector(0.0, 1.0)\n\n    \"\"\"\n    if subspace is None:\n        warnings.warn(\n            \"No subspace given: the vector is projected onto the first component!\", stacklevel=2\n        )\n        return Vector(self.x, 0)\n    else:\n        # Note that self is the instance of the Vector class\n        projection_coef: float = (subspace * self) / subspace.norm**2\n        return subspace * projection_coef\n</code></pre>"},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Script to generate the documentation pages and navigation for our library.\n\nImportant: remember to change PATH_LIBRARY to whatever name your package\nfolder has!!\n\"\"\"\n</pre> \"\"\"Script to generate the documentation pages and navigation for our library.  Important: remember to change PATH_LIBRARY to whatever name your package folder has!! \"\"\" In\u00a0[\u00a0]: Copied! <pre>import sys\nimport os\nfrom pathlib import Path\n</pre> import sys import os from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nPATH_LIBRARY = \"mypackage\"  # change this with your library's name\n</pre> nav = mkdocs_gen_files.Nav() PATH_LIBRARY = \"mypackage\"  # change this with your library's name In\u00a0[\u00a0]: Copied! <pre>if os.path.isdir(PATH_LIBRARY) is False:\n    sys.exit(\n        \"Package folder was not found. Please change the PATH_LIBRARY\"\n        \" variable in the docs/scripts/gen_ref_nav.py script.\"\n    )\n</pre> if os.path.isdir(PATH_LIBRARY) is False:     sys.exit(         \"Package folder was not found. Please change the PATH_LIBRARY\"         \" variable in the docs/scripts/gen_ref_nav.py script.\"     ) In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(PATH_LIBRARY).rglob(\"*.py\")):\n    module_path = path.relative_to(\"\").with_suffix(\"\")\n    doc_path = path.relative_to(PATH_LIBRARY).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\\n\")\n        fd.write(\"\\thandler: python\\n\")\n        fd.write(\"\\toptions:\\n\")\n        fd.write(\"\\t\\tshow_root_heading: true\\n\")\n        fd.write(\"\\t\\tshow_source: true\\n\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(Path(PATH_LIBRARY).rglob(\"*.py\")):     module_path = path.relative_to(\"\").with_suffix(\"\")     doc_path = path.relative_to(PATH_LIBRARY).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\\n\")         fd.write(\"\\thandler: python\\n\")         fd.write(\"\\toptions:\\n\")         fd.write(\"\\t\\tshow_root_heading: true\\n\")         fd.write(\"\\t\\tshow_source: true\\n\")      mkdocs_gen_files.set_edit_path(full_doc_path, path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}